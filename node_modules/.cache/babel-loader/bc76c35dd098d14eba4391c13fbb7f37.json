{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowsLookupSelector } from '../rows/gridRowsSelector';\nimport { gridSelectionStateSelector, selectedGridRowsSelector, selectedIdsLookupSelector } from './gridSelectionSelector';\nimport { gridPaginatedVisibleSortedGridRowIdsSelector } from '../pagination';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridVisibleSortedRowIdsSelector } from '../filter/gridFilterSelector';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF, GRID_ACTIONS_COLUMN_TYPE } from '../../../colDef';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isNavigationKey } from '../../../utils/keyboardUtils';\nimport { getVisibleRows, useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\nimport { gridClasses } from '../../../constants/gridClasses';\n\nconst getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {\n  if (selectionModelProp == null) {\n    return selectionModelProp;\n  }\n\n  if (Array.isArray(selectionModelProp)) {\n    return selectionModelProp;\n  }\n\n  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {\n    return prevSelectionModel;\n  }\n\n  return [selectionModelProp];\n};\n\nexport const selectionStateInitializer = (state, props) => {\n  var _getSelectionModelPro;\n\n  return _extends({}, state, {\n    selection: (_getSelectionModelPro = getSelectionModelPropValue(props.selectionModel)) != null ? _getSelectionModelPro : []\n  });\n};\n/**\n * @requires useGridRows (state, method) - can be after\n * @requires useGridParamsApi (method) - can be after\n * @requires useGridFocus (state) - can be after\n * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)\n */\n\nexport const useGridSelection = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridSelection');\n  const propSelectionModel = React.useMemo(() => {\n    return getSelectionModelPropValue(props.selectionModel, gridSelectionStateSelector(apiRef.current.state));\n  }, [apiRef, props.selectionModel]);\n  const lastRowToggled = React.useRef(null);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'selection',\n    propModel: propSelectionModel,\n    propOnChange: props.onSelectionModelChange,\n    stateSelector: gridSelectionStateSelector,\n    changeEvent: 'selectionChange'\n  });\n  const {\n    checkboxSelection,\n    disableMultipleSelection,\n    disableSelectionOnClick,\n    pagination,\n    paginationMode,\n    isRowSelectable: propIsRowSelectable\n  } = props;\n  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;\n  const visibleRows = useGridVisibleRows(apiRef, props);\n  const expandMouseRowRangeSelection = React.useCallback(id => {\n    var _lastRowToggled$curre;\n\n    let endId = id;\n    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (isSelected) {\n      const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n      const startIndex = visibleRowIds.findIndex(rowId => rowId === startId);\n      const endIndex = visibleRowIds.findIndex(rowId => rowId === endId);\n\n      if (startIndex === endIndex) {\n        return;\n      }\n\n      if (startIndex > endIndex) {\n        endId = visibleRowIds[endIndex + 1];\n      } else {\n        endId = visibleRowIds[endIndex - 1];\n      }\n    }\n\n    lastRowToggled.current = id;\n    apiRef.current.selectRowRange({\n      startId,\n      endId\n    }, !isSelected);\n  }, [apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setSelectionModel = React.useCallback(model => {\n    const currentModel = gridSelectionStateSelector(apiRef.current.state);\n\n    if (currentModel !== model) {\n      logger.debug(`Setting selection model`);\n      apiRef.current.setState(state => _extends({}, state, {\n        selection: model\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, logger]);\n  const isRowSelected = React.useCallback(id => gridSelectionStateSelector(apiRef.current.state).includes(id), [apiRef]);\n  const isRowSelectable = React.useCallback(id => {\n    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id))) {\n      return false;\n    }\n\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((rowNode == null ? void 0 : rowNode.position) === 'footer' || rowNode != null && rowNode.isPinned) {\n      return false;\n    }\n\n    return true;\n  }, [apiRef, propIsRowSelectable]);\n  const getSelectedRows = React.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);\n  const selectRow = React.useCallback(function (id) {\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!apiRef.current.isRowSelectable(id)) {\n      return;\n    }\n\n    lastRowToggled.current = id;\n\n    if (resetSelection) {\n      logger.debug(`Setting selection for row ${id}`);\n      apiRef.current.setSelectionModel(isSelected ? [id] : []);\n    } else {\n      logger.debug(`Toggling selection for row ${id}`);\n      const selection = gridSelectionStateSelector(apiRef.current.state);\n      const newSelection = selection.filter(el => el !== id);\n\n      if (isSelected) {\n        newSelection.push(id);\n      }\n\n      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n      if (isSelectionValid) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRows = React.useCallback(function (ids) {\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    logger.debug(`Setting selection for several rows`);\n    const selectableIds = ids.filter(id => apiRef.current.isRowSelectable(id));\n    let newSelection;\n\n    if (resetSelection) {\n      newSelection = isSelected ? selectableIds : [];\n    } else {\n      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n      const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n      selectableIds.forEach(id => {\n        if (isSelected) {\n          selectionLookup[id] = id;\n        } else {\n          delete selectionLookup[id];\n        }\n      });\n      newSelection = Object.values(selectionLookup);\n    }\n\n    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n    if (isSelectionValid) {\n      apiRef.current.setSelectionModel(newSelection);\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRowRange = React.useCallback(function (_ref) {\n    let {\n      startId,\n      endId\n    } = _ref;\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {\n      return;\n    }\n\n    logger.debug(`Expanding selection from row ${startId} to row ${endId}`); // Using rows from all pages allow to select a range across several pages\n\n    const allPagesRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n    const startIndex = allPagesRowIds.indexOf(startId);\n    const endIndex = allPagesRowIds.indexOf(endId);\n    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];\n    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start, end + 1);\n    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);\n  }, [apiRef, logger]);\n  const selectionApi = {\n    selectRow,\n    selectRows,\n    selectRowRange,\n    setSelectionModel,\n    getSelectedRows,\n    isRowSelected,\n    isRowSelectable\n  };\n  useGridApiMethod(apiRef, selectionApi, 'GridSelectionApi');\n  /**\n   * EVENTS\n   */\n\n  const removeOutdatedSelection = React.useCallback(() => {\n    if (props.keepNonExistentRowsSelected) {\n      return;\n    }\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    const rowsLookup = gridRowsLookupSelector(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n\n    const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n    let hasChanged = false;\n    currentSelection.forEach(id => {\n      if (!rowsLookup[id]) {\n        delete selectionLookup[id];\n        hasChanged = true;\n      }\n    });\n\n    if (hasChanged) {\n      apiRef.current.setSelectionModel(Object.values(selectionLookup));\n    }\n  }, [apiRef, props.keepNonExistentRowsSelected]);\n  const handleSingleRowSelection = React.useCallback((id, event) => {\n    const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:\n    // - it is a checkboxSelection\n    // - it is a keyboard selection\n    // - Ctrl is pressed\n\n    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);\n    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (resetSelection) {\n      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);\n    } else {\n      apiRef.current.selectRow(id, !isSelected, false);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);\n  const handleRowClick = React.useCallback((params, event) => {\n    var _closest;\n\n    if (disableSelectionOnClick) {\n      return;\n    }\n\n    const field = (_closest = event.target.closest(`.${gridClasses.cell}`)) == null ? void 0 : _closest.getAttribute('data-field');\n\n    if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // click on checkbox should not trigger row selection\n      return;\n    }\n\n    if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n      // click to open the detail panel should not select the row\n      return;\n    }\n\n    if (field) {\n      const column = apiRef.current.getColumn(field);\n\n      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {\n        return;\n      }\n    }\n\n    const rowNode = apiRef.current.getRowNode(params.id);\n\n    if (rowNode.isPinned) {\n      return;\n    }\n\n    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      handleSingleRowSelection(params.id, event);\n    }\n  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);\n  const preventSelectionOnShift = React.useCallback((params, event) => {\n    if (canHaveMultipleSelection && event.shiftKey) {\n      var _window$getSelection;\n\n      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();\n    }\n  }, [canHaveMultipleSelection]);\n  const handleRowSelectionCheckboxChange = React.useCallback((params, event) => {\n    if (event.nativeEvent.shiftKey) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      apiRef.current.selectRow(params.id, params.value);\n    }\n  }, [apiRef, expandMouseRowRangeSelection]);\n  const handleHeaderSelectionCheckboxChange = React.useCallback(params => {\n    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;\n    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridVisibleSortedRowIdsSelector(apiRef);\n    apiRef.current.selectRows(rowsToBeSelected, params.value);\n  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);\n  const handleCellKeyDown = React.useCallback((params, event) => {\n    // Get the most recent cell mode because it may have been changed by another listener\n    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {\n      return;\n    } // Ignore portal\n    // Do not apply shortcuts if the focus is not on the cell root component\n\n\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    }\n\n    if (isNavigationKey(event.key) && event.shiftKey) {\n      // The cell that has focus after the keyboard navigation\n      const focusCell = gridFocusCellSelector(apiRef);\n\n      if (focusCell && focusCell.id !== params.id) {\n        event.preventDefault();\n        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);\n\n        if (!canHaveMultipleSelection) {\n          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);\n          return;\n        }\n\n        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);\n        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);\n        let start;\n        let end;\n\n        if (newRowIndex > previousRowIndex) {\n          if (isNextRowSelected) {\n            // We are navigating to the bottom of the page and adding selected rows\n            start = previousRowIndex;\n            end = newRowIndex - 1;\n          } else {\n            // We are navigating to the bottom of the page and removing selected rows\n            start = previousRowIndex;\n            end = newRowIndex;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isNextRowSelected) {\n            // We are navigating to the top of the page and removing selected rows\n            start = newRowIndex + 1;\n            end = previousRowIndex;\n          } else {\n            // We are navigating to the top of the page and adding selected rows\n            start = newRowIndex;\n            end = previousRowIndex;\n          }\n        }\n\n        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start, end + 1).map(row => row.id);\n        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);\n        return;\n      }\n    }\n\n    if (event.key === ' ' && event.shiftKey) {\n      event.preventDefault();\n      handleSingleRowSelection(params.id, event);\n      return;\n    }\n\n    if (event.key.toLowerCase() === 'a' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      selectRows(apiRef.current.getAllRowIds(), true);\n    }\n  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', removeOutdatedSelection);\n  useGridApiEventHandler(apiRef, 'rowClick', handleRowClick);\n  useGridApiEventHandler(apiRef, 'rowSelectionCheckboxChange', handleRowSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'headerSelectionCheckboxChange', handleHeaderSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'cellMouseDown', preventSelectionOnShift);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    if (propSelectionModel !== undefined) {\n      apiRef.current.setSelectionModel(propSelectionModel);\n    }\n  }, [apiRef, propSelectionModel]);\n  const isStateControlled = propSelectionModel != null;\n  React.useEffect(() => {\n    if (isStateControlled) {\n      return;\n    } // props.isRowSelectable changed\n\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (isRowSelectable) {\n      const newSelection = currentSelection.filter(id => isRowSelectable(id));\n\n      if (newSelection.length < currentSelection.length) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, isRowSelectable, isStateControlled]);\n  React.useEffect(() => {\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (!canHaveMultipleSelection && currentSelection.length > 1) {\n      const {\n        rows: currentPageRows\n      } = getVisibleRows(apiRef, {\n        pagination,\n        paginationMode\n      });\n      const currentPageRowsLookup = currentPageRows.reduce((acc, _ref2) => {\n        let {\n          id\n        } = _ref2;\n        acc[id] = true;\n        return acc;\n      }, {});\n      const firstSelectableRow = currentSelection.find(id => {\n        let isSelectable = true;\n\n        if (isRowSelectable) {\n          isSelectable = isRowSelectable(id);\n        }\n\n        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page\n      });\n      apiRef.current.setSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);\n};","map":{"version":3,"sources":["/Users/sidram/VSCODEFILES/youtube2022/node_modules/@mui/x-data-grid/hooks/features/selection/useGridSelection.js"],"names":["_extends","React","useGridApiEventHandler","useGridApiMethod","useGridLogger","gridRowsLookupSelector","gridSelectionStateSelector","selectedGridRowsSelector","selectedIdsLookupSelector","gridPaginatedVisibleSortedGridRowIdsSelector","gridFocusCellSelector","gridVisibleSortedRowIdsSelector","GRID_CHECKBOX_SELECTION_COL_DEF","GRID_ACTIONS_COLUMN_TYPE","GridCellModes","isKeyboardEvent","isNavigationKey","getVisibleRows","useGridVisibleRows","GRID_DETAIL_PANEL_TOGGLE_FIELD","gridClasses","getSelectionModelPropValue","selectionModelProp","prevSelectionModel","Array","isArray","selectionStateInitializer","state","props","_getSelectionModelPro","selection","selectionModel","useGridSelection","apiRef","logger","propSelectionModel","useMemo","current","lastRowToggled","useRef","unstable_registerControlState","stateId","propModel","propOnChange","onSelectionModelChange","stateSelector","changeEvent","checkboxSelection","disableMultipleSelection","disableSelectionOnClick","pagination","paginationMode","isRowSelectable","propIsRowSelectable","canHaveMultipleSelection","visibleRows","expandMouseRowRangeSelection","useCallback","id","_lastRowToggled$curre","endId","startId","isSelected","isRowSelected","visibleRowIds","startIndex","findIndex","rowId","endIndex","selectRowRange","setSelectionModel","model","currentModel","debug","setState","forceUpdate","includes","getRowParams","rowNode","getRowNode","position","isPinned","getSelectedRows","selectRow","resetSelection","newSelection","filter","el","push","isSelectionValid","length","selectRows","ids","selectableIds","selectionLookup","forEach","Object","values","getRow","allPagesRowIds","indexOf","start","end","rowsBetweenStartAndEnd","slice","selectionApi","removeOutdatedSelection","keepNonExistentRowsSelected","currentSelection","rowsLookup","hasChanged","handleSingleRowSelection","event","hasCtrlKey","metaKey","ctrlKey","isMultipleSelectionDisabled","handleRowClick","params","_closest","field","target","closest","cell","getAttribute","column","getColumn","type","shiftKey","preventSelectionOnShift","_window$getSelection","window","getSelection","removeAllRanges","handleRowSelectionCheckboxChange","nativeEvent","value","handleHeaderSelectionCheckboxChange","shouldLimitSelectionToCurrentPage","checkboxSelectionVisibleOnly","rowsToBeSelected","handleCellKeyDown","getCellMode","Edit","currentTarget","contains","key","focusCell","preventDefault","isNextRowSelected","newRowIndex","getRowIndexRelativeToVisibleRows","previousRowIndex","rows","map","row","toLowerCase","getAllRowIds","useEffect","undefined","isStateControlled","currentPageRows","currentPageRowsLookup","reduce","acc","firstSelectableRow","find","isSelectable"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowsLookupSelector } from '../rows/gridRowsSelector';\nimport { gridSelectionStateSelector, selectedGridRowsSelector, selectedIdsLookupSelector } from './gridSelectionSelector';\nimport { gridPaginatedVisibleSortedGridRowIdsSelector } from '../pagination';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridVisibleSortedRowIdsSelector } from '../filter/gridFilterSelector';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF, GRID_ACTIONS_COLUMN_TYPE } from '../../../colDef';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isNavigationKey } from '../../../utils/keyboardUtils';\nimport { getVisibleRows, useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\nimport { gridClasses } from '../../../constants/gridClasses';\n\nconst getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {\n  if (selectionModelProp == null) {\n    return selectionModelProp;\n  }\n\n  if (Array.isArray(selectionModelProp)) {\n    return selectionModelProp;\n  }\n\n  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {\n    return prevSelectionModel;\n  }\n\n  return [selectionModelProp];\n};\n\nexport const selectionStateInitializer = (state, props) => {\n  var _getSelectionModelPro;\n\n  return _extends({}, state, {\n    selection: (_getSelectionModelPro = getSelectionModelPropValue(props.selectionModel)) != null ? _getSelectionModelPro : []\n  });\n};\n/**\n * @requires useGridRows (state, method) - can be after\n * @requires useGridParamsApi (method) - can be after\n * @requires useGridFocus (state) - can be after\n * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)\n */\n\nexport const useGridSelection = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridSelection');\n  const propSelectionModel = React.useMemo(() => {\n    return getSelectionModelPropValue(props.selectionModel, gridSelectionStateSelector(apiRef.current.state));\n  }, [apiRef, props.selectionModel]);\n  const lastRowToggled = React.useRef(null);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'selection',\n    propModel: propSelectionModel,\n    propOnChange: props.onSelectionModelChange,\n    stateSelector: gridSelectionStateSelector,\n    changeEvent: 'selectionChange'\n  });\n  const {\n    checkboxSelection,\n    disableMultipleSelection,\n    disableSelectionOnClick,\n    pagination,\n    paginationMode,\n    isRowSelectable: propIsRowSelectable\n  } = props;\n  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;\n  const visibleRows = useGridVisibleRows(apiRef, props);\n  const expandMouseRowRangeSelection = React.useCallback(id => {\n    var _lastRowToggled$curre;\n\n    let endId = id;\n    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (isSelected) {\n      const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n      const startIndex = visibleRowIds.findIndex(rowId => rowId === startId);\n      const endIndex = visibleRowIds.findIndex(rowId => rowId === endId);\n\n      if (startIndex === endIndex) {\n        return;\n      }\n\n      if (startIndex > endIndex) {\n        endId = visibleRowIds[endIndex + 1];\n      } else {\n        endId = visibleRowIds[endIndex - 1];\n      }\n    }\n\n    lastRowToggled.current = id;\n    apiRef.current.selectRowRange({\n      startId,\n      endId\n    }, !isSelected);\n  }, [apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setSelectionModel = React.useCallback(model => {\n    const currentModel = gridSelectionStateSelector(apiRef.current.state);\n\n    if (currentModel !== model) {\n      logger.debug(`Setting selection model`);\n      apiRef.current.setState(state => _extends({}, state, {\n        selection: model\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, logger]);\n  const isRowSelected = React.useCallback(id => gridSelectionStateSelector(apiRef.current.state).includes(id), [apiRef]);\n  const isRowSelectable = React.useCallback(id => {\n    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id))) {\n      return false;\n    }\n\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((rowNode == null ? void 0 : rowNode.position) === 'footer' || rowNode != null && rowNode.isPinned) {\n      return false;\n    }\n\n    return true;\n  }, [apiRef, propIsRowSelectable]);\n  const getSelectedRows = React.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);\n  const selectRow = React.useCallback((id, isSelected = true, resetSelection = false) => {\n    if (!apiRef.current.isRowSelectable(id)) {\n      return;\n    }\n\n    lastRowToggled.current = id;\n\n    if (resetSelection) {\n      logger.debug(`Setting selection for row ${id}`);\n      apiRef.current.setSelectionModel(isSelected ? [id] : []);\n    } else {\n      logger.debug(`Toggling selection for row ${id}`);\n      const selection = gridSelectionStateSelector(apiRef.current.state);\n      const newSelection = selection.filter(el => el !== id);\n\n      if (isSelected) {\n        newSelection.push(id);\n      }\n\n      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n      if (isSelectionValid) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRows = React.useCallback((ids, isSelected = true, resetSelection = false) => {\n    logger.debug(`Setting selection for several rows`);\n    const selectableIds = ids.filter(id => apiRef.current.isRowSelectable(id));\n    let newSelection;\n\n    if (resetSelection) {\n      newSelection = isSelected ? selectableIds : [];\n    } else {\n      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n      const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n      selectableIds.forEach(id => {\n        if (isSelected) {\n          selectionLookup[id] = id;\n        } else {\n          delete selectionLookup[id];\n        }\n      });\n      newSelection = Object.values(selectionLookup);\n    }\n\n    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n    if (isSelectionValid) {\n      apiRef.current.setSelectionModel(newSelection);\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRowRange = React.useCallback(({\n    startId,\n    endId\n  }, isSelected = true, resetSelection) => {\n    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {\n      return;\n    }\n\n    logger.debug(`Expanding selection from row ${startId} to row ${endId}`); // Using rows from all pages allow to select a range across several pages\n\n    const allPagesRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n    const startIndex = allPagesRowIds.indexOf(startId);\n    const endIndex = allPagesRowIds.indexOf(endId);\n    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];\n    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start, end + 1);\n    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);\n  }, [apiRef, logger]);\n  const selectionApi = {\n    selectRow,\n    selectRows,\n    selectRowRange,\n    setSelectionModel,\n    getSelectedRows,\n    isRowSelected,\n    isRowSelectable\n  };\n  useGridApiMethod(apiRef, selectionApi, 'GridSelectionApi');\n  /**\n   * EVENTS\n   */\n\n  const removeOutdatedSelection = React.useCallback(() => {\n    if (props.keepNonExistentRowsSelected) {\n      return;\n    }\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    const rowsLookup = gridRowsLookupSelector(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n\n    const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n    let hasChanged = false;\n    currentSelection.forEach(id => {\n      if (!rowsLookup[id]) {\n        delete selectionLookup[id];\n        hasChanged = true;\n      }\n    });\n\n    if (hasChanged) {\n      apiRef.current.setSelectionModel(Object.values(selectionLookup));\n    }\n  }, [apiRef, props.keepNonExistentRowsSelected]);\n  const handleSingleRowSelection = React.useCallback((id, event) => {\n    const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:\n    // - it is a checkboxSelection\n    // - it is a keyboard selection\n    // - Ctrl is pressed\n\n    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);\n    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (resetSelection) {\n      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);\n    } else {\n      apiRef.current.selectRow(id, !isSelected, false);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);\n  const handleRowClick = React.useCallback((params, event) => {\n    var _closest;\n\n    if (disableSelectionOnClick) {\n      return;\n    }\n\n    const field = (_closest = event.target.closest(`.${gridClasses.cell}`)) == null ? void 0 : _closest.getAttribute('data-field');\n\n    if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // click on checkbox should not trigger row selection\n      return;\n    }\n\n    if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n      // click to open the detail panel should not select the row\n      return;\n    }\n\n    if (field) {\n      const column = apiRef.current.getColumn(field);\n\n      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {\n        return;\n      }\n    }\n\n    const rowNode = apiRef.current.getRowNode(params.id);\n\n    if (rowNode.isPinned) {\n      return;\n    }\n\n    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      handleSingleRowSelection(params.id, event);\n    }\n  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);\n  const preventSelectionOnShift = React.useCallback((params, event) => {\n    if (canHaveMultipleSelection && event.shiftKey) {\n      var _window$getSelection;\n\n      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();\n    }\n  }, [canHaveMultipleSelection]);\n  const handleRowSelectionCheckboxChange = React.useCallback((params, event) => {\n    if (event.nativeEvent.shiftKey) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      apiRef.current.selectRow(params.id, params.value);\n    }\n  }, [apiRef, expandMouseRowRangeSelection]);\n  const handleHeaderSelectionCheckboxChange = React.useCallback(params => {\n    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;\n    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridVisibleSortedRowIdsSelector(apiRef);\n    apiRef.current.selectRows(rowsToBeSelected, params.value);\n  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);\n  const handleCellKeyDown = React.useCallback((params, event) => {\n    // Get the most recent cell mode because it may have been changed by another listener\n    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {\n      return;\n    } // Ignore portal\n    // Do not apply shortcuts if the focus is not on the cell root component\n\n\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    }\n\n    if (isNavigationKey(event.key) && event.shiftKey) {\n      // The cell that has focus after the keyboard navigation\n      const focusCell = gridFocusCellSelector(apiRef);\n\n      if (focusCell && focusCell.id !== params.id) {\n        event.preventDefault();\n        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);\n\n        if (!canHaveMultipleSelection) {\n          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);\n          return;\n        }\n\n        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);\n        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);\n        let start;\n        let end;\n\n        if (newRowIndex > previousRowIndex) {\n          if (isNextRowSelected) {\n            // We are navigating to the bottom of the page and adding selected rows\n            start = previousRowIndex;\n            end = newRowIndex - 1;\n          } else {\n            // We are navigating to the bottom of the page and removing selected rows\n            start = previousRowIndex;\n            end = newRowIndex;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isNextRowSelected) {\n            // We are navigating to the top of the page and removing selected rows\n            start = newRowIndex + 1;\n            end = previousRowIndex;\n          } else {\n            // We are navigating to the top of the page and adding selected rows\n            start = newRowIndex;\n            end = previousRowIndex;\n          }\n        }\n\n        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start, end + 1).map(row => row.id);\n        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);\n        return;\n      }\n    }\n\n    if (event.key === ' ' && event.shiftKey) {\n      event.preventDefault();\n      handleSingleRowSelection(params.id, event);\n      return;\n    }\n\n    if (event.key.toLowerCase() === 'a' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      selectRows(apiRef.current.getAllRowIds(), true);\n    }\n  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', removeOutdatedSelection);\n  useGridApiEventHandler(apiRef, 'rowClick', handleRowClick);\n  useGridApiEventHandler(apiRef, 'rowSelectionCheckboxChange', handleRowSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'headerSelectionCheckboxChange', handleHeaderSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'cellMouseDown', preventSelectionOnShift);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    if (propSelectionModel !== undefined) {\n      apiRef.current.setSelectionModel(propSelectionModel);\n    }\n  }, [apiRef, propSelectionModel]);\n  const isStateControlled = propSelectionModel != null;\n  React.useEffect(() => {\n    if (isStateControlled) {\n      return;\n    } // props.isRowSelectable changed\n\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (isRowSelectable) {\n      const newSelection = currentSelection.filter(id => isRowSelectable(id));\n\n      if (newSelection.length < currentSelection.length) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, isRowSelectable, isStateControlled]);\n  React.useEffect(() => {\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (!canHaveMultipleSelection && currentSelection.length > 1) {\n      const {\n        rows: currentPageRows\n      } = getVisibleRows(apiRef, {\n        pagination,\n        paginationMode\n      });\n      const currentPageRowsLookup = currentPageRows.reduce((acc, {\n        id\n      }) => {\n        acc[id] = true;\n        return acc;\n      }, {});\n      const firstSelectableRow = currentSelection.find(id => {\n        let isSelectable = true;\n\n        if (isRowSelectable) {\n          isSelectable = isRowSelectable(id);\n        }\n\n        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page\n      });\n      apiRef.current.setSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);\n};"]},"metadata":{},"sourceType":"module"}