{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref2, index) => {\n    let {\n      id\n    } = _ref2;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.unstable_caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange(cache, true);\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqueUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      rowCountPropBeforePartialUpdates: prevCache.rowCountPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqueUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(_ref3 => {\n    let {\n      skipAutoGeneratedRows = true,\n      groupId,\n      applySorting,\n      applyFiltering\n    } = _ref3;\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const allRows = gridRowIdsSelector(apiRef);\n    const updatedRows = [...allRows];\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    const idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    const tree = gridRowTreeSelector(apiRef);\n\n    const updatedIdRowsLookup = _extends({}, idRowsLookup);\n\n    const updatedIdToIdLookup = _extends({}, idToIdLookup);\n\n    const updatedTree = _extends({}, tree);\n\n    const newRowEntries = newRows.map(newRowModel => {\n      const rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach((row, index) => {\n      const [replacedRowId] = updatedRows.splice(firstRowToRender + index, 1, row.id);\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(row => {\n      const rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.unstable_caches.rows.idRowsLookup = updatedIdRowsLookup;\n    apiRef.current.unstable_caches.rows.idToIdLookup = updatedIdToIdLookup;\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        idRowsLookup: updatedIdRowsLookup,\n        idToIdLookup: updatedIdToIdLookup,\n        tree: updatedTree,\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"sources":["/Users/sidram/VSCODEFILES/youtube2022/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","gridRowsIdToIdLookupSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","unstable_caches","rows","getRowId","loading","rowCount","previousTree","rowCountProp","loadingProp","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","_ref","lookup","useMemo","reduce","acc","index","throttledRowsChange","newCache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","length","cache","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","uniqueUpdates","Map","forEach","update","has","set","get","deletedRowIds","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","idRowsLookup","idToIdLookup","ids","partialRow","_action","push","oldRow","filter","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","tree","_gridRowTreeSelector$","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","node","isAutoGenerated","filteredRowsLookup","childId","setRowIndex","rowId","targetIndex","oldIndex","row","updatedRows","splice","replaceRows","firstRowToRender","newRows","updatedIdRowsLookup","updatedIdToIdLookup","updatedTree","newRowEntries","newRowModel","model","replacedRowId","rowTreeNodeConfig","parent","groupingKey","groupingField","rowApi","unstable_replaceRows","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","applyHydrateRowsProcessor","unstable_applyPipeProcessors","groupingResponseBeforeRowHydration","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","isNewRowCountAlreadyInState","totalRowCount","Math","max","totalTopLevelRowCount"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.unstable_caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange(cache, true);\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqueUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      rowCountPropBeforePartialUpdates: prevCache.rowCountPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqueUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const allRows = gridRowIdsSelector(apiRef);\n    const updatedRows = [...allRows];\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    const idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    const tree = gridRowTreeSelector(apiRef);\n\n    const updatedIdRowsLookup = _extends({}, idRowsLookup);\n\n    const updatedIdToIdLookup = _extends({}, idToIdLookup);\n\n    const updatedTree = _extends({}, tree);\n\n    const newRowEntries = newRows.map(newRowModel => {\n      const rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach((row, index) => {\n      const [replacedRowId] = updatedRows.splice(firstRowToRender + index, 1, row.id);\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(row => {\n      const rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.unstable_caches.rows.idRowsLookup = updatedIdRowsLookup;\n    apiRef.current.unstable_caches.rows.idToIdLookup = updatedIdToIdLookup;\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        idRowsLookup: updatedIdRowsLookup,\n        idToIdLookup: updatedIdToIdLookup,\n        tree: updatedTree,\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"]},"metadata":{},"sourceType":"module"}